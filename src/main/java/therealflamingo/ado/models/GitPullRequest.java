/*
 * Git
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 7.2-preview
 * Contact: nugetvss@microsoft.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package therealflamingo.ado.models;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import org.threeten.bp.OffsetDateTime;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.UUID;

/**
 * Represents all the data associated with a pull request.
 */
@ApiModel(description = "Represents all the data associated with a pull request.")
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2024-07-28T21:17:42.501+02:00")
public class GitPullRequest {
  @JsonProperty("_links")
  private ReferenceLinks links = null;

  @JsonProperty("artifactId")
  private String artifactId = null;

  @JsonProperty("autoCompleteSetBy")
  private IdentityRef autoCompleteSetBy = null;

  @JsonProperty("closedBy")
  private IdentityRef closedBy = null;

  @JsonProperty("closedDate")
  private OffsetDateTime closedDate = null;

  @JsonProperty("codeReviewId")
  private Integer codeReviewId = null;

  @JsonProperty("commits")
  private List<GitCommitRef> commits = null;

  @JsonProperty("completionOptions")
  private GitPullRequestCompletionOptions completionOptions = null;

  @JsonProperty("completionQueueTime")
  private OffsetDateTime completionQueueTime = null;

  @JsonProperty("createdBy")
  private IdentityRef createdBy = null;

  @JsonProperty("creationDate")
  private OffsetDateTime creationDate = null;

  @JsonProperty("description")
  private String description = null;

  @JsonProperty("forkSource")
  private GitForkRef forkSource = null;

  @JsonProperty("hasMultipleMergeBases")
  private Boolean hasMultipleMergeBases = null;

  @JsonProperty("isDraft")
  private Boolean isDraft = null;

  @JsonProperty("labels")
  private List<WebApiTagDefinition> labels = null;

  @JsonProperty("lastMergeCommit")
  private GitCommitRef lastMergeCommit = null;

  @JsonProperty("lastMergeSourceCommit")
  private GitCommitRef lastMergeSourceCommit = null;

  @JsonProperty("lastMergeTargetCommit")
  private GitCommitRef lastMergeTargetCommit = null;

  @JsonProperty("mergeFailureMessage")
  private String mergeFailureMessage = null;
  @JsonProperty("mergeFailureType")
  private MergeFailureTypeEnum mergeFailureType = null;
  @JsonProperty("mergeId")
  private UUID mergeId = null;
  @JsonProperty("mergeOptions")
  private GitPullRequestMergeOptions mergeOptions = null;
  @JsonProperty("mergeStatus")
  private MergeStatusEnum mergeStatus = null;
  @JsonProperty("pullRequestId")
  private Integer pullRequestId = null;
  @JsonProperty("remoteUrl")
  private String remoteUrl = null;
  @JsonProperty("repository")
  private GitRepository repository = null;
  @JsonProperty("reviewers")
  private List<IdentityRefWithVote> reviewers = null;
  @JsonProperty("sourceRefName")
  private String sourceRefName = null;
  @JsonProperty("status")
  private StatusEnum status = null;
  @JsonProperty("supportsIterations")
  private Boolean supportsIterations = null;
  @JsonProperty("targetRefName")
  private String targetRefName = null;
  @JsonProperty("title")
  private String title = null;
  @JsonProperty("url")
  private String url = null;
  @JsonProperty("workItemRefs")
  private List<ResourceRef> workItemRefs = null;

  public GitPullRequest links(ReferenceLinks links) {
    this.links = links;
    return this;
  }

  /**
   * Links to other related objects.
   *
   * @return links
   **/
  @ApiModelProperty(value = "Links to other related objects.")
  public ReferenceLinks getLinks() {
    return links;
  }

  public void setLinks(ReferenceLinks links) {
    this.links = links;
  }

  public GitPullRequest artifactId(String artifactId) {
    this.artifactId = artifactId;
    return this;
  }

  /**
   * A string which uniquely identifies this pull request. To generate an artifact ID for a pull request, use this template: &#x60;&#x60;&#x60;vstfs:///Git/PullRequestId/{projectId}/{repositoryId}/{pullRequestId}&#x60;&#x60;&#x60;
   *
   * @return artifactId
   **/
  @ApiModelProperty(value = "A string which uniquely identifies this pull request. To generate an artifact ID for a pull request, use this template: ```vstfs:///Git/PullRequestId/{projectId}/{repositoryId}/{pullRequestId}```")
  public String getArtifactId() {
    return artifactId;
  }

  public void setArtifactId(String artifactId) {
    this.artifactId = artifactId;
  }

  public GitPullRequest autoCompleteSetBy(IdentityRef autoCompleteSetBy) {
    this.autoCompleteSetBy = autoCompleteSetBy;
    return this;
  }

  /**
   * If set, auto-complete is enabled for this pull request and this is the identity that enabled it.
   *
   * @return autoCompleteSetBy
   **/
  @ApiModelProperty(value = "If set, auto-complete is enabled for this pull request and this is the identity that enabled it.")
  public IdentityRef getAutoCompleteSetBy() {
    return autoCompleteSetBy;
  }

  public void setAutoCompleteSetBy(IdentityRef autoCompleteSetBy) {
    this.autoCompleteSetBy = autoCompleteSetBy;
  }

  public GitPullRequest closedBy(IdentityRef closedBy) {
    this.closedBy = closedBy;
    return this;
  }

  /**
   * The user who closed the pull request.
   *
   * @return closedBy
   **/
  @ApiModelProperty(value = "The user who closed the pull request.")
  public IdentityRef getClosedBy() {
    return closedBy;
  }

  public void setClosedBy(IdentityRef closedBy) {
    this.closedBy = closedBy;
  }

  public GitPullRequest closedDate(OffsetDateTime closedDate) {
    this.closedDate = closedDate;
    return this;
  }

  /**
   * The date when the pull request was closed (completed, abandoned, or merged externally).
   *
   * @return closedDate
   **/
  @ApiModelProperty(value = "The date when the pull request was closed (completed, abandoned, or merged externally).")
  public OffsetDateTime getClosedDate() {
    return closedDate;
  }

  public void setClosedDate(OffsetDateTime closedDate) {
    this.closedDate = closedDate;
  }

  public GitPullRequest codeReviewId(Integer codeReviewId) {
    this.codeReviewId = codeReviewId;
    return this;
  }

  /**
   * The code review ID of the pull request. Used internally.
   *
   * @return codeReviewId
   **/
  @ApiModelProperty(value = "The code review ID of the pull request. Used internally.")
  public Integer getCodeReviewId() {
    return codeReviewId;
  }

  public void setCodeReviewId(Integer codeReviewId) {
    this.codeReviewId = codeReviewId;
  }

  public GitPullRequest commits(List<GitCommitRef> commits) {
    this.commits = commits;
    return this;
  }

  public GitPullRequest addCommitsItem(GitCommitRef commitsItem) {
    if (this.commits == null) {
      this.commits = new ArrayList<GitCommitRef>();
    }
    this.commits.add(commitsItem);
    return this;
  }

  /**
   * The commits contained in the pull request.
   *
   * @return commits
   **/
  @ApiModelProperty(value = "The commits contained in the pull request.")
  public List<GitCommitRef> getCommits() {
    return commits;
  }

  public void setCommits(List<GitCommitRef> commits) {
    this.commits = commits;
  }

  public GitPullRequest completionOptions(GitPullRequestCompletionOptions completionOptions) {
    this.completionOptions = completionOptions;
    return this;
  }

  /**
   * Options which affect how the pull request will be merged when it is completed.
   *
   * @return completionOptions
   **/
  @ApiModelProperty(value = "Options which affect how the pull request will be merged when it is completed.")
  public GitPullRequestCompletionOptions getCompletionOptions() {
    return completionOptions;
  }

  public void setCompletionOptions(GitPullRequestCompletionOptions completionOptions) {
    this.completionOptions = completionOptions;
  }

  public GitPullRequest completionQueueTime(OffsetDateTime completionQueueTime) {
    this.completionQueueTime = completionQueueTime;
    return this;
  }

  /**
   * The most recent date at which the pull request entered the queue to be completed. Used internally.
   *
   * @return completionQueueTime
   **/
  @ApiModelProperty(value = "The most recent date at which the pull request entered the queue to be completed. Used internally.")
  public OffsetDateTime getCompletionQueueTime() {
    return completionQueueTime;
  }

  public void setCompletionQueueTime(OffsetDateTime completionQueueTime) {
    this.completionQueueTime = completionQueueTime;
  }

  public GitPullRequest createdBy(IdentityRef createdBy) {
    this.createdBy = createdBy;
    return this;
  }

  /**
   * The identity of the user who created the pull request.
   *
   * @return createdBy
   **/
  @ApiModelProperty(value = "The identity of the user who created the pull request.")
  public IdentityRef getCreatedBy() {
    return createdBy;
  }

  public void setCreatedBy(IdentityRef createdBy) {
    this.createdBy = createdBy;
  }

  public GitPullRequest creationDate(OffsetDateTime creationDate) {
    this.creationDate = creationDate;
    return this;
  }

  /**
   * The date when the pull request was created.
   *
   * @return creationDate
   **/
  @ApiModelProperty(value = "The date when the pull request was created.")
  public OffsetDateTime getCreationDate() {
    return creationDate;
  }

  public void setCreationDate(OffsetDateTime creationDate) {
    this.creationDate = creationDate;
  }

  public GitPullRequest description(String description) {
    this.description = description;
    return this;
  }

  /**
   * The description of the pull request.
   *
   * @return description
   **/
  @ApiModelProperty(value = "The description of the pull request.")
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }

  public GitPullRequest forkSource(GitForkRef forkSource) {
    this.forkSource = forkSource;
    return this;
  }

  /**
   * If this is a PR from a fork this will contain information about its source.
   *
   * @return forkSource
   **/
  @ApiModelProperty(value = "If this is a PR from a fork this will contain information about its source.")
  public GitForkRef getForkSource() {
    return forkSource;
  }

  public void setForkSource(GitForkRef forkSource) {
    this.forkSource = forkSource;
  }

  public GitPullRequest hasMultipleMergeBases(Boolean hasMultipleMergeBases) {
    this.hasMultipleMergeBases = hasMultipleMergeBases;
    return this;
  }

  /**
   * Multiple mergebases warning
   *
   * @return hasMultipleMergeBases
   **/
  @ApiModelProperty(value = "Multiple mergebases warning")
  public Boolean isHasMultipleMergeBases() {
    return hasMultipleMergeBases;
  }

  public void setHasMultipleMergeBases(Boolean hasMultipleMergeBases) {
    this.hasMultipleMergeBases = hasMultipleMergeBases;
  }

  public GitPullRequest isDraft(Boolean isDraft) {
    this.isDraft = isDraft;
    return this;
  }

  /**
   * Draft / WIP pull request.
   *
   * @return isDraft
   **/
  @ApiModelProperty(value = "Draft / WIP pull request.")
  public Boolean isIsDraft() {
    return isDraft;
  }

  public void setIsDraft(Boolean isDraft) {
    this.isDraft = isDraft;
  }

  public GitPullRequest labels(List<WebApiTagDefinition> labels) {
    this.labels = labels;
    return this;
  }

  public GitPullRequest addLabelsItem(WebApiTagDefinition labelsItem) {
    if (this.labels == null) {
      this.labels = new ArrayList<WebApiTagDefinition>();
    }
    this.labels.add(labelsItem);
    return this;
  }

  /**
   * The labels associated with the pull request.
   *
   * @return labels
   **/
  @ApiModelProperty(value = "The labels associated with the pull request.")
  public List<WebApiTagDefinition> getLabels() {
    return labels;
  }

  public void setLabels(List<WebApiTagDefinition> labels) {
    this.labels = labels;
  }

  public GitPullRequest lastMergeCommit(GitCommitRef lastMergeCommit) {
    this.lastMergeCommit = lastMergeCommit;
    return this;
  }

  /**
   * The commit of the most recent pull request merge. If empty, the most recent merge is in progress or was unsuccessful.
   *
   * @return lastMergeCommit
   **/
  @ApiModelProperty(value = "The commit of the most recent pull request merge. If empty, the most recent merge is in progress or was unsuccessful.")
  public GitCommitRef getLastMergeCommit() {
    return lastMergeCommit;
  }

  public void setLastMergeCommit(GitCommitRef lastMergeCommit) {
    this.lastMergeCommit = lastMergeCommit;
  }

  public GitPullRequest lastMergeSourceCommit(GitCommitRef lastMergeSourceCommit) {
    this.lastMergeSourceCommit = lastMergeSourceCommit;
    return this;
  }

  /**
   * The commit at the head of the source branch at the time of the last pull request merge.
   *
   * @return lastMergeSourceCommit
   **/
  @ApiModelProperty(value = "The commit at the head of the source branch at the time of the last pull request merge.")
  public GitCommitRef getLastMergeSourceCommit() {
    return lastMergeSourceCommit;
  }

  public void setLastMergeSourceCommit(GitCommitRef lastMergeSourceCommit) {
    this.lastMergeSourceCommit = lastMergeSourceCommit;
  }

  public GitPullRequest lastMergeTargetCommit(GitCommitRef lastMergeTargetCommit) {
    this.lastMergeTargetCommit = lastMergeTargetCommit;
    return this;
  }

  /**
   * The commit at the head of the target branch at the time of the last pull request merge.
   *
   * @return lastMergeTargetCommit
   **/
  @ApiModelProperty(value = "The commit at the head of the target branch at the time of the last pull request merge.")
  public GitCommitRef getLastMergeTargetCommit() {
    return lastMergeTargetCommit;
  }

  public void setLastMergeTargetCommit(GitCommitRef lastMergeTargetCommit) {
    this.lastMergeTargetCommit = lastMergeTargetCommit;
  }

  public GitPullRequest mergeFailureMessage(String mergeFailureMessage) {
    this.mergeFailureMessage = mergeFailureMessage;
    return this;
  }

  /**
   * If set, pull request merge failed for this reason.
   *
   * @return mergeFailureMessage
   **/
  @ApiModelProperty(value = "If set, pull request merge failed for this reason.")
  public String getMergeFailureMessage() {
    return mergeFailureMessage;
  }

  public void setMergeFailureMessage(String mergeFailureMessage) {
    this.mergeFailureMessage = mergeFailureMessage;
  }

  public GitPullRequest mergeFailureType(MergeFailureTypeEnum mergeFailureType) {
    this.mergeFailureType = mergeFailureType;
    return this;
  }

  /**
   * The type of failure (if any) of the pull request merge.
   *
   * @return mergeFailureType
   **/
  @ApiModelProperty(value = "The type of failure (if any) of the pull request merge.")
  public MergeFailureTypeEnum getMergeFailureType() {
    return mergeFailureType;
  }

  public void setMergeFailureType(MergeFailureTypeEnum mergeFailureType) {
    this.mergeFailureType = mergeFailureType;
  }

  public GitPullRequest mergeId(UUID mergeId) {
    this.mergeId = mergeId;
    return this;
  }

  /**
   * The ID of the job used to run the pull request merge. Used internally.
   *
   * @return mergeId
   **/
  @ApiModelProperty(value = "The ID of the job used to run the pull request merge. Used internally.")
  public UUID getMergeId() {
    return mergeId;
  }

  public void setMergeId(UUID mergeId) {
    this.mergeId = mergeId;
  }

  public GitPullRequest mergeOptions(GitPullRequestMergeOptions mergeOptions) {
    this.mergeOptions = mergeOptions;
    return this;
  }

  /**
   * Options used when the pull request merge runs. These are separate from completion options since completion happens only once and a new merge will run every time the source branch of the pull request changes.
   *
   * @return mergeOptions
   **/
  @ApiModelProperty(value = "Options used when the pull request merge runs. These are separate from completion options since completion happens only once and a new merge will run every time the source branch of the pull request changes.")
  public GitPullRequestMergeOptions getMergeOptions() {
    return mergeOptions;
  }

  public void setMergeOptions(GitPullRequestMergeOptions mergeOptions) {
    this.mergeOptions = mergeOptions;
  }

  public GitPullRequest mergeStatus(MergeStatusEnum mergeStatus) {
    this.mergeStatus = mergeStatus;
    return this;
  }

  /**
   * The current status of the pull request merge.
   *
   * @return mergeStatus
   **/
  @ApiModelProperty(value = "The current status of the pull request merge.")
  public MergeStatusEnum getMergeStatus() {
    return mergeStatus;
  }

  public void setMergeStatus(MergeStatusEnum mergeStatus) {
    this.mergeStatus = mergeStatus;
  }

  public GitPullRequest pullRequestId(Integer pullRequestId) {
    this.pullRequestId = pullRequestId;
    return this;
  }

  /**
   * The ID of the pull request.
   *
   * @return pullRequestId
   **/
  @ApiModelProperty(value = "The ID of the pull request.")
  public Integer getPullRequestId() {
    return pullRequestId;
  }

  public void setPullRequestId(Integer pullRequestId) {
    this.pullRequestId = pullRequestId;
  }

  public GitPullRequest remoteUrl(String remoteUrl) {
    this.remoteUrl = remoteUrl;
    return this;
  }

  /**
   * Used internally.
   *
   * @return remoteUrl
   **/
  @ApiModelProperty(value = "Used internally.")
  public String getRemoteUrl() {
    return remoteUrl;
  }

  public void setRemoteUrl(String remoteUrl) {
    this.remoteUrl = remoteUrl;
  }

  public GitPullRequest repository(GitRepository repository) {
    this.repository = repository;
    return this;
  }

  /**
   * The repository containing the target branch of the pull request.
   *
   * @return repository
   **/
  @ApiModelProperty(value = "The repository containing the target branch of the pull request.")
  public GitRepository getRepository() {
    return repository;
  }

  public void setRepository(GitRepository repository) {
    this.repository = repository;
  }

  public GitPullRequest reviewers(List<IdentityRefWithVote> reviewers) {
    this.reviewers = reviewers;
    return this;
  }

  public GitPullRequest addReviewersItem(IdentityRefWithVote reviewersItem) {
    if (this.reviewers == null) {
      this.reviewers = new ArrayList<IdentityRefWithVote>();
    }
    this.reviewers.add(reviewersItem);
    return this;
  }

  /**
   * A list of reviewers on the pull request along with the state of their votes.
   *
   * @return reviewers
   **/
  @ApiModelProperty(value = "A list of reviewers on the pull request along with the state of their votes.")
  public List<IdentityRefWithVote> getReviewers() {
    return reviewers;
  }

  public void setReviewers(List<IdentityRefWithVote> reviewers) {
    this.reviewers = reviewers;
  }

  public GitPullRequest sourceRefName(String sourceRefName) {
    this.sourceRefName = sourceRefName;
    return this;
  }

  /**
   * The name of the source branch of the pull request.
   *
   * @return sourceRefName
   **/
  @ApiModelProperty(value = "The name of the source branch of the pull request.")
  public String getSourceRefName() {
    return sourceRefName;
  }

  public void setSourceRefName(String sourceRefName) {
    this.sourceRefName = sourceRefName;
  }

  public GitPullRequest status(StatusEnum status) {
    this.status = status;
    return this;
  }

  /**
   * The status of the pull request.
   *
   * @return status
   **/
  @ApiModelProperty(value = "The status of the pull request.")
  public StatusEnum getStatus() {
    return status;
  }

  public void setStatus(StatusEnum status) {
    this.status = status;
  }

  public GitPullRequest supportsIterations(Boolean supportsIterations) {
    this.supportsIterations = supportsIterations;
    return this;
  }

  /**
   * If true, this pull request supports multiple iterations. Iteration support means individual pushes to the source branch of the pull request can be reviewed and comments left in one iteration will be tracked across future iterations.
   *
   * @return supportsIterations
   **/
  @ApiModelProperty(value = "If true, this pull request supports multiple iterations. Iteration support means individual pushes to the source branch of the pull request can be reviewed and comments left in one iteration will be tracked across future iterations.")
  public Boolean isSupportsIterations() {
    return supportsIterations;
  }

  public void setSupportsIterations(Boolean supportsIterations) {
    this.supportsIterations = supportsIterations;
  }

  public GitPullRequest targetRefName(String targetRefName) {
    this.targetRefName = targetRefName;
    return this;
  }

  /**
   * The name of the target branch of the pull request.
   *
   * @return targetRefName
   **/
  @ApiModelProperty(value = "The name of the target branch of the pull request.")
  public String getTargetRefName() {
    return targetRefName;
  }

  public void setTargetRefName(String targetRefName) {
    this.targetRefName = targetRefName;
  }

  public GitPullRequest title(String title) {
    this.title = title;
    return this;
  }

  /**
   * The title of the pull request.
   *
   * @return title
   **/
  @ApiModelProperty(value = "The title of the pull request.")
  public String getTitle() {
    return title;
  }

  public void setTitle(String title) {
    this.title = title;
  }

  public GitPullRequest url(String url) {
    this.url = url;
    return this;
  }

  /**
   * Used internally.
   *
   * @return url
   **/
  @ApiModelProperty(value = "Used internally.")
  public String getUrl() {
    return url;
  }

  public void setUrl(String url) {
    this.url = url;
  }

  public GitPullRequest workItemRefs(List<ResourceRef> workItemRefs) {
    this.workItemRefs = workItemRefs;
    return this;
  }

  public GitPullRequest addWorkItemRefsItem(ResourceRef workItemRefsItem) {
    if (this.workItemRefs == null) {
      this.workItemRefs = new ArrayList<ResourceRef>();
    }
    this.workItemRefs.add(workItemRefsItem);
    return this;
  }

  /**
   * Any work item references associated with this pull request.
   *
   * @return workItemRefs
   **/
  @ApiModelProperty(value = "Any work item references associated with this pull request.")
  public List<ResourceRef> getWorkItemRefs() {
    return workItemRefs;
  }

  public void setWorkItemRefs(List<ResourceRef> workItemRefs) {
    this.workItemRefs = workItemRefs;
  }

  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GitPullRequest gitPullRequest = (GitPullRequest) o;
    return Objects.equals(this.links, gitPullRequest.links) &&
            Objects.equals(this.artifactId, gitPullRequest.artifactId) &&
            Objects.equals(this.autoCompleteSetBy, gitPullRequest.autoCompleteSetBy) &&
            Objects.equals(this.closedBy, gitPullRequest.closedBy) &&
            Objects.equals(this.closedDate, gitPullRequest.closedDate) &&
            Objects.equals(this.codeReviewId, gitPullRequest.codeReviewId) &&
            Objects.equals(this.commits, gitPullRequest.commits) &&
            Objects.equals(this.completionOptions, gitPullRequest.completionOptions) &&
            Objects.equals(this.completionQueueTime, gitPullRequest.completionQueueTime) &&
            Objects.equals(this.createdBy, gitPullRequest.createdBy) &&
            Objects.equals(this.creationDate, gitPullRequest.creationDate) &&
            Objects.equals(this.description, gitPullRequest.description) &&
            Objects.equals(this.forkSource, gitPullRequest.forkSource) &&
            Objects.equals(this.hasMultipleMergeBases, gitPullRequest.hasMultipleMergeBases) &&
            Objects.equals(this.isDraft, gitPullRequest.isDraft) &&
            Objects.equals(this.labels, gitPullRequest.labels) &&
            Objects.equals(this.lastMergeCommit, gitPullRequest.lastMergeCommit) &&
            Objects.equals(this.lastMergeSourceCommit, gitPullRequest.lastMergeSourceCommit) &&
            Objects.equals(this.lastMergeTargetCommit, gitPullRequest.lastMergeTargetCommit) &&
            Objects.equals(this.mergeFailureMessage, gitPullRequest.mergeFailureMessage) &&
            Objects.equals(this.mergeFailureType, gitPullRequest.mergeFailureType) &&
            Objects.equals(this.mergeId, gitPullRequest.mergeId) &&
            Objects.equals(this.mergeOptions, gitPullRequest.mergeOptions) &&
            Objects.equals(this.mergeStatus, gitPullRequest.mergeStatus) &&
            Objects.equals(this.pullRequestId, gitPullRequest.pullRequestId) &&
            Objects.equals(this.remoteUrl, gitPullRequest.remoteUrl) &&
            Objects.equals(this.repository, gitPullRequest.repository) &&
            Objects.equals(this.reviewers, gitPullRequest.reviewers) &&
            Objects.equals(this.sourceRefName, gitPullRequest.sourceRefName) &&
            Objects.equals(this.status, gitPullRequest.status) &&
            Objects.equals(this.supportsIterations, gitPullRequest.supportsIterations) &&
            Objects.equals(this.targetRefName, gitPullRequest.targetRefName) &&
            Objects.equals(this.title, gitPullRequest.title) &&
            Objects.equals(this.url, gitPullRequest.url) &&
            Objects.equals(this.workItemRefs, gitPullRequest.workItemRefs);
  }

  @Override
  public int hashCode() {
    return Objects.hash(links, artifactId, autoCompleteSetBy, closedBy, closedDate, codeReviewId, commits, completionOptions, completionQueueTime, createdBy, creationDate, description, forkSource, hasMultipleMergeBases, isDraft, labels, lastMergeCommit, lastMergeSourceCommit, lastMergeTargetCommit, mergeFailureMessage, mergeFailureType, mergeId, mergeOptions, mergeStatus, pullRequestId, remoteUrl, repository, reviewers, sourceRefName, status, supportsIterations, targetRefName, title, url, workItemRefs);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GitPullRequest {\n");

    sb.append("    links: ").append(toIndentedString(links)).append("\n");
    sb.append("    artifactId: ").append(toIndentedString(artifactId)).append("\n");
    sb.append("    autoCompleteSetBy: ").append(toIndentedString(autoCompleteSetBy)).append("\n");
    sb.append("    closedBy: ").append(toIndentedString(closedBy)).append("\n");
    sb.append("    closedDate: ").append(toIndentedString(closedDate)).append("\n");
    sb.append("    codeReviewId: ").append(toIndentedString(codeReviewId)).append("\n");
    sb.append("    commits: ").append(toIndentedString(commits)).append("\n");
    sb.append("    completionOptions: ").append(toIndentedString(completionOptions)).append("\n");
    sb.append("    completionQueueTime: ").append(toIndentedString(completionQueueTime)).append("\n");
    sb.append("    createdBy: ").append(toIndentedString(createdBy)).append("\n");
    sb.append("    creationDate: ").append(toIndentedString(creationDate)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    forkSource: ").append(toIndentedString(forkSource)).append("\n");
    sb.append("    hasMultipleMergeBases: ").append(toIndentedString(hasMultipleMergeBases)).append("\n");
    sb.append("    isDraft: ").append(toIndentedString(isDraft)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    lastMergeCommit: ").append(toIndentedString(lastMergeCommit)).append("\n");
    sb.append("    lastMergeSourceCommit: ").append(toIndentedString(lastMergeSourceCommit)).append("\n");
    sb.append("    lastMergeTargetCommit: ").append(toIndentedString(lastMergeTargetCommit)).append("\n");
    sb.append("    mergeFailureMessage: ").append(toIndentedString(mergeFailureMessage)).append("\n");
    sb.append("    mergeFailureType: ").append(toIndentedString(mergeFailureType)).append("\n");
    sb.append("    mergeId: ").append(toIndentedString(mergeId)).append("\n");
    sb.append("    mergeOptions: ").append(toIndentedString(mergeOptions)).append("\n");
    sb.append("    mergeStatus: ").append(toIndentedString(mergeStatus)).append("\n");
    sb.append("    pullRequestId: ").append(toIndentedString(pullRequestId)).append("\n");
    sb.append("    remoteUrl: ").append(toIndentedString(remoteUrl)).append("\n");
    sb.append("    repository: ").append(toIndentedString(repository)).append("\n");
    sb.append("    reviewers: ").append(toIndentedString(reviewers)).append("\n");
    sb.append("    sourceRefName: ").append(toIndentedString(sourceRefName)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    supportsIterations: ").append(toIndentedString(supportsIterations)).append("\n");
    sb.append("    targetRefName: ").append(toIndentedString(targetRefName)).append("\n");
    sb.append("    title: ").append(toIndentedString(title)).append("\n");
    sb.append("    url: ").append(toIndentedString(url)).append("\n");
    sb.append("    workItemRefs: ").append(toIndentedString(workItemRefs)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

  /**
   * The type of failure (if any) of the pull request merge.
   */
  public enum MergeFailureTypeEnum {
    NONE("none"),

    UNKNOWN("unknown"),

    CASESENSITIVE("caseSensitive"),

    OBJECTTOOLARGE("objectTooLarge");

    private String value;

    MergeFailureTypeEnum(String value) {
      this.value = value;
    }

    @JsonCreator
    public static MergeFailureTypeEnum fromValue(String value) {
      for (MergeFailureTypeEnum b : MergeFailureTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      return null;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
  }


  /**
   * The current status of the pull request merge.
   */
  public enum MergeStatusEnum {
    NOTSET("notSet"),

    QUEUED("queued"),

    CONFLICTS("conflicts"),

    SUCCEEDED("succeeded"),

    REJECTEDBYPOLICY("rejectedByPolicy"),

    FAILURE("failure");

    private String value;

    MergeStatusEnum(String value) {
      this.value = value;
    }

    @JsonCreator
    public static MergeStatusEnum fromValue(String value) {
      for (MergeStatusEnum b : MergeStatusEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      return null;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
  }

  /**
   * The status of the pull request.
   */
  public enum StatusEnum {
    NOTSET("notSet"),

    ACTIVE("active"),

    ABANDONED("abandoned"),

    COMPLETED("completed"),

    ALL("all");

    private String value;

    StatusEnum(String value) {
      this.value = value;
    }

    @JsonCreator
    public static StatusEnum fromValue(String value) {
      for (StatusEnum b : StatusEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      return null;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
  }

}

